# Majority Element

## Intuition

The problem asks us to find the element that appears **more than ⌊n/2⌋ times** in the array.  
A direct frequency count using a hashmap works but uses extra space. Instead, we can solve it in constant space using the **Boyer–Moore Majority Vote Algorithm**, which cleverly cancels out non-majority elements until only the true majority remains.

---

## Approach (Boyer–Moore Majority Vote Algorithm)

1. Initialize two variables:
   - `candidate` → the current candidate for majority.
   - `count` → how strongly this candidate is supported.

2. Iterate through the array:
   - If `count == 0`, pick the current number as the new `candidate`.
   - If the number matches the `candidate`, increment `count`.
   - Otherwise, decrement `count`.

3. After one pass, the remaining `candidate` is guaranteed to be the majority element (since it appears more than ⌊n/2⌋ times).

---

## Complexity

- **Time complexity:** O(n) — single scan through the array.
- **Space complexity:** O(1) — only two variables are used.

---

## Code

```python
class Solution:
    def majorityElement(self, nums: List[int]) -> int:
        candidate = None
        count = 0
        for num in nums:
            if count == 0:
                candidate = num

            count += 1 if candidate == num else -1
        return candidate
```
