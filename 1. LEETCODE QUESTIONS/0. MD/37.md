# Merge Sorted Array

# Intuition

We are given two sorted arrays, `nums1` and `nums2`, where `nums1` has extra space at the end to accommodate all elements.  
The goal is to merge `nums2` into `nums1` so that `nums1` becomes a single sorted array.

A natural first thought is to use two pointers from the start of both arrays, but this risks overwriting elements in `nums1` before they are placed in their final position.  
Instead, if we fill from the **end of nums1**, we avoid overwriting because the largest elements are placed first.

---

# Approach

1. Initialize three pointers:
   - `p1 = m - 1` → last element of the valid part of `nums1`.
   - `p2 = n - 1` → last element of `nums2`.
   - `p = m + n - 1` → last index of `nums1` (final position to fill).
2. Compare elements from the back:
   - If `nums1[p1] > nums2[p2]`, place `nums1[p1]` at `nums1[p]` and move `p1` left.
   - Otherwise, place `nums2[p2]` at `nums1[p]` and move `p2` left.
   - Always decrement `p`.
3. If `nums2` still has remaining elements, copy them into `nums1`.  
   (No need to copy leftovers from `nums1` since they are already in place).

---

# Complexity

- **Time complexity:** $$O(m+n)$$ — each element is processed once.
- **Space complexity:** $$O(1)$$ — merging is done in-place without extra arrays.

---

# Code

```python3 []
class Solution:
    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:
        p1 = m - 1
        p2 = n - 1
        p = m + n - 1

        while p1 >= 0 and p2 >= 0:
            if nums1[p1] > nums2[p2]:
                nums1[p] = nums1[p1]
                p1 -= 1
            else:
                nums1[p] = nums2[p2]
                p2 -= 1
            p -= 1

        while p2 >= 0:
            nums1[p] = nums2[p2]
            p2 -= 1
            p -= 1
```
