# Intuition

We need to find the index of the target in a sorted array.  
If the target is not present, we should return the index where it would be inserted in order to maintain sorted order.  
Since the array is sorted, **binary search** is the most efficient approach instead of linear scanning.

# Approach

1. Initialize two pointers:
   - `l = 0` (start of array)
   - `r = len(nums) - 1` (end of array)
2. While `l <= r`:
   - Compute `mid = (l + r) // 2`.
   - If `nums[mid] == target`, return `mid`.
   - If `nums[mid] < target`, move search to the right half (`l = mid + 1`).
   - Else, move search to the left half (`r = mid - 1`).
3. If the loop ends without finding the target, the correct insert position is `r + 1`.

# Complexity

- **Time complexity:** $$O(\log n)$$ — binary search halves the search space each step.
- **Space complexity:** $$O(1)$$ — only a few variables are used.

# Code

```python3 []
class Solution:
    def searchInsert(self, nums: List[int], target: int) -> int:
        l = 0
        r = len(nums) - 1
        while l <= r:
            mid = (l + r) // 2
            if nums[mid] == target:
                return mid
            elif nums[mid] < target:
                l = mid + 1
            else:
                r = mid - 1
        return r + 1
```
