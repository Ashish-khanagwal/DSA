# Knuth-Morris-Pratt (KMP) String Matching Algorithm

## Overview

KMP is a smart algorithm for searching a pattern inside a string. It's much faster than brute force methods because it remembers previous matches, so it never rechecks the same characters unnecessarily. It's widely used for text searching in editors, bioinformatics, and coding interviews.

---

## 1. The Problem: Pattern Search

Given:

- **String (haystack):** The text to search in.
- **Pattern (needle):** The sequence to find.

Goal:

- Check if the pattern exists in the string, and if so, where.

---

## 2. Brute Force (Naive Approach)

- Try matching the pattern at every position in the string.
- If there's a mismatch, move to the next position and start over.
- This often leads to repeated comparisons of the same substrings.

**Example 1:**

- String: `a b c d e f g h`
- Pattern: `def`

Naive search:

- Start at index 0 → mismatch
- Start at index 1 → mismatch
- …
- Start at index 3 → match found!

**Drawback:** Lots of repeated work. If parts of the string/pattern match partially, brute force doesn’t use that information to save time.

---

## 3. The Key Idea Behind KMP

When a mismatch happens, KMP uses the information of previously matched characters to "jump" ahead—using something called the **LPS Table**—so the algorithm doesn't redo the same comparisons.

- **LPS (Longest Prefix Suffix):** For every position in the pattern, LPS stores the length of the longest prefix that is also a suffix from the pattern's start.
- This lets KMP know how far it can safely skip ahead when a mismatch occurs.

---

## 4. Building the LPS Table

The LPS table is the core of KMP. It tells you, for each position in the pattern, what is the longest prefix that is also a suffix (excluding the whole string).

**Steps to build it:**

1. Start with the first character (LPS is always 0).
2. Move through the pattern:
   - If the character matches the prefix, increment LPS value.
   - If there’s a mismatch, look back at previous LPS values for the new starting point.

**Example:**  
Pattern: `a b c d a b c`  
LPS: `[0 0 0 0 1 2 3]`

Meaning:

- At index 4 (`a`), the longest prefix that’s also a suffix is `"a"`.
- At index 6 (`c`), the longest prefix-suffix is `"abc"` of length 3.

---

## 5. KMP Algorithm — Step by Step

### Main Steps:

1. Build the LPS table for the pattern.
2. Use two pointers (i for haystack, j for needle).
3. If characters match, move both pointers.
4. If mismatch:
   - If `j > 0`, move `j` using LPS (don’t reset to 0).
   - If `j == 0`, move `i` in haystack.
5. If `j == len(needle)`, we found a match → return `i - len(needle)`.

---

## 6. Example Traces (How KMP Works)

### Example 1: Simple

- String: `A A A X A A A A`
- Pattern: `A A A A`
- LPS: `[0, 1, 2, 3]`

**Step-by-step:**

- Start matching → `AAA` matched
- Mismatch at `X` → Instead of starting over, jump `j` using LPS → `j = 3`
- Continue matching → match found at index `4`.

---

### Example 2: Trickier Match

- String: `a b x a b c a b c a b y`
- Pattern: `a b c a b y`

Build LPS: `[0, 0, 0, 1, 2, 0]`

**Trace:**

1. `a b` matches → continue.
2. Mismatch at `x` → `j` resets using LPS → no wasted work.
3. Move forward → `a b c a b y` fully matches starting at index `6`.

Answer: Found at index `6`.

---

### Example 3: Pattern Not Found

- String: `a b c d e f`
- Pattern: `x y z`  
  No matches → KMP runs through the haystack once and returns `-1`.

---

## 7. Why KMP is Fast

- **No unnecessary rechecking:** It never moves the haystack pointer backward.
- **Time Complexity:** O(N + M), where N = length of string, M = length of pattern.
- **Space Complexity:** O(M), for the LPS table.
- Even in worst cases with many repeated characters, it stays linear.

---

## 8. Pitfalls & Edge Cases

- If the pattern is very repetitive (e.g., `aaaabaaa`), the LPS table will have higher values — but KMP still skips intelligently.
- If `needle == ""`, by definition return `0`.
- Must handle mismatches correctly: if `j > 0`, reset `j` using LPS; don’t reset `i`.

---

## 9. LeetCode Implementation – `strStr()`

### Intuition

We need to find the first occurrence of `needle` in `haystack`.  
Naive approach is **O(n \* m)**, but KMP reduces it to **O(n + m)** by skipping unnecessary checks using the LPS table.

---

### Approach

1. Handle edge case: if `needle` is empty, return `0`.
2. Build the **LPS array** for `needle`.
3. Perform KMP search:
   - If match, move both pointers.
   - If mismatch and `j > 0`, reset `j` using LPS.
   - If mismatch and `j == 0`, move `i`.
4. If `j == len(needle)`, return match index.
5. If no match found, return `-1`.

---

### Complexity

- **Time complexity:** O(n + m)
- **Space complexity:** O(m) (LPS array)

---

### Code

```
class Solution:
    def strStr(self, haystack: str, needle: str) -> int:
        if needle == "":
            return 0

        # Step 1: Build LPS array
        lps = [0] * len(needle)
        prevLPS, i = 0, 1
        while i < len(needle):
            if needle[i] == needle[prevLPS]:
                lps[i] = prevLPS + 1
                prevLPS += 1
                i += 1
            elif prevLPS == 0:
                lps[i] = 0
                i += 1
            else:
                prevLPS = lps[prevLPS - 1]

        # Step 2: KMP search
        i = j = 0
        while i < len(haystack):
            if haystack[i] == needle[j]:
                i, j = i + 1, j + 1
            else:
                if j == 0:
                    i += 1
                else:
                    j = lps[j - 1]
            if j == len(needle):
                return i - len(needle)
        return -1
```
