# Intuition

We are asked to find the **first bad version** among versions `1` to `n`.  
Since once a version is bad, all versions after it are also bad, this forms a **monotonic sequence** (good → good → … → bad → bad → …).  
This property allows us to use **binary search** instead of checking each version one by one.

---

# Approach

1. Initialize two pointers:
   - `l = 1` (lowest version).
   - `r = n` (highest version).
2. Perform binary search:
   - Compute `m = (l + r) // 2`.
   - If `isBadVersion(m)` is **True**, the first bad version must be at `m` or before, so update `r = m - 1`.
   - Otherwise, the first bad version must be after `m`, so update `l = m + 1`.
3. When the loop ends, `l` will point to the **first bad version**.

---

# Complexity

- **Time Complexity:** $$O(\log n)$$
  - Because binary search divides the search space in half at each step.

- **Space Complexity:** $$O(1)$$
  - Only a few variables are used.

---

# Code

```python3 []
# The isBadVersion API is already defined for you.
# def isBadVersion(version: int) -> bool:

class Solution:
    def firstBadVersion(self, n: int) -> int:
        l, r = 1, n   # search between 1 and n
        while l <= r:
            m = l + (r - l) // 2
            if isBadVersion(m):
                r = m - 1
            else:
                l = m + 1
        return l

```
