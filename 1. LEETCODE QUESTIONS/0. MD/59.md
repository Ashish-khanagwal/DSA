# Intuition

We are given a rotated sorted array, and the task is to find the minimum element.  
Since the array is sorted and then rotated, the minimum element is the **pivot point** where the rotation happens.  
Binary search can be applied because the array still retains partial sorted properties.

---

# Approach

1. Initialize two pointers:
   - `l = 0` (left)
   - `r = len(nums) - 1` (right)
2. While `l < r`:
   - Compute `mid = (l + r) // 2`.
   - If `nums[mid] > nums[r]`, it means the minimum lies in the **right half**, so update `l = mid + 1`.
   - Otherwise, the minimum lies in the **left half** (including `mid`), so update `r = mid`.
3. When the loop ends, both `l` and `r` point to the minimum element.
4. Return `nums[r]`.

---

# Complexity

- **Time Complexity:** $$O(\log n)$$
  - Binary search reduces the search space by half each time.

- **Space Complexity:** $$O(1)$$
  - Only a few variables are used regardless of input size.

---

# Code

```python3 []
class Solution:
    def findMin(self, nums: List[int]) -> int:
        l, r = 0, len(nums) - 1
        while l < r:
            mid = (l + r) // 2
            if nums[mid] > nums[r]:
                l = mid + 1
            else:
                r = mid
        return nums[r]

```
