# Sort Vowels in a String

---

## Version 1: Sorting and Rebuilding

### Intuition

We need to sort all vowels in the string by their ASCII values while leaving consonants in place.  
A straightforward idea is to **extract vowels, sort them, and then put them back** into the original positions.

### Approach

1. Identify all vowels in the string.
2. Sort the vowels using Python's built-in `sorted()` function.
3. Iterate over the original string:
   - If the character is a consonant, keep it in place.
   - If it is a vowel, replace it with the next vowel from the sorted list.
4. Join the characters to form the result string.

### Complexity

- **Time complexity:** $$O(n \log n)$$ — sorting the vowels dominates.
- **Space complexity:** $$O(n)$$ — to store the list of characters and sorted vowels.

### Code

```
def sortVowels(s):
  vowels = set("aeiouAEIOU")
  v = sorted([c for c in s if c in vowels], key=ord)
  it = iter(v)
  f = []
  for c in s:
    if c not in vowels:
      f.append(c)
    else:
      f.append(next(it))
  t = "".join(ch for ch in f)
  return t

print(sortVowels("lEetcOde"))
print(sortVowels("lYmpH"))
```

---

## Version 2: Generator/Iterative Approach

### Intuition

This is a **more concise version** of version 1. The idea remains the same, but we use a generator to fetch the next sorted vowel on the fly.

### Approach

1. Extract vowels and sort them.
2. Create an iterator over the sorted vowels.
3. Construct the result string in one line using a generator expression:
   - Replace vowels with `next(iterator)`.
   - Leave consonants unchanged.

### Complexity

- **Time complexity:** $$O(n \log n)$$ — sorting is the dominant factor.
- **Space complexity:** $$O(n)$$ — for storing sorted vowels and the result string.

### Code

```
def sortVowels(s):
  vowels = set("aeiouAEIOU")
  v = sorted([c for c in s if c in vowels], key=ord)
  it = iter(v)
  return "".join(next(it) if c in vowels else c for c in s)

print(sortVowels("lEetcOde"))
print(sortVowels("lYmpH"))
```

---

## Version 3: Counting Sort (Best Version)

### Intuition

Since vowels have **limited ASCII range**, we can sort them using **counting sort**, achieving **linear time complexity**.  
This avoids the O(n log n) overhead of built-in sorting.

### Approach

1. Extract vowels from the string.
2. Find the minimum and maximum ASCII values among vowels.
3. Build a count array for each ASCII value (counting sort).
4. Reconstruct the sorted vowels from the count array.
5. Replace vowels in the original string using an iterator over the sorted vowels.
6. Join the characters to form the final string.

### Complexity

- **Time complexity:** $$O(n)$$ — linear pass to collect, count, and rebuild vowels.
- **Space complexity:** $$O(n)$$ — for the list of vowels and the final string.

### Code

```
def sortVowels(s):
  vowels_set = set("aeiouAEIOU")
  # Step 1: Collect vowels from s
  vowels = [c for c in s if c in vowels_set]

  # Step 2: Counting sort based on ASCII values
  if not vowels:
    return s      # no vowels, return original

  min_ascii = min(ord(c) for c in vowels)
  max_ascii = max(ord(c) for c in vowels)
  k = max_ascii - min_ascii + 1

  count = [0]*k
  for c in vowels:
    count[ord(c) - min_ascii] += 1

  # Step 3: Reconstruct sorted vowels
  sorted_vowels = []
  for i in range(k):
    sorted_vowels.extend([chr(i + min_ascii)] * count[i])

  # Step 4: Replace vowels in original string
  it = iter(sorted_vowels)
  result = [next(it) if c in vowels_set else c for c in s]

  return "".join(result)

print(sortVowels("lEetcOde"))
print(sortVowels("lYmpH"))
```
