# Guess Number Higher or Lower

# Intuition

The problem is essentially a **number guessing game** where the API `guess(num)` helps us know if our guess is too high, too low, or correct.  
Since the number lies between `1` and `n`, and the feedback allows us to eliminate half of the search space each time, this is a perfect use case for **binary search**.

---

# Approach

1. Initialize two pointers:
   - `l = 1` (smallest possible number).
   - `r = n` (largest possible number).
2. While `l <= r`:
   - Compute `mid = (l + r) // 2`.
   - Call `guess(mid)` to check:
     - If result is `0`, we found the number → return `mid`.
     - If result is `-1`, the picked number is smaller → search left half (`r = mid - 1`).
     - If result is `1`, the picked number is larger → search right half (`l = mid + 1`).
3. Continue until the number is found.

---

# Complexity

- **Time complexity:** $$O(\log n)$$ — each step halves the search range.
- **Space complexity:** $$O(1)$$ — only a few pointers are used.

---

# Code

```
# The guess API is already defined for you.
# @param num, your guess
# @return -1 if num is higher than the picked number
#          1 if num is lower than the picked number
#          otherwise return 0
# def guess(num: int) -> int:

class Solution:
    def guessNumber(self, n: int) -> int:
        l = 1
        r = n
        while l <= r:
            mid = (l + r) // 2
            num = guess(mid)
            if num == 0:
                return mid
            elif num == -1:
                r = mid - 1
            else:
                l = mid + 1
```
