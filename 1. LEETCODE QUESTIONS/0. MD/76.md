# Intuition

We are asked to maximize the number of **distinct elements** in an array after performing `k` operations,  
where each element can be increased or decreased by `k`.  
The idea is to try to **assign numbers greedily** so that no two numbers collide after modification.

---

# Approach

1. **Sort the array**. This ensures we handle smaller numbers first, which helps in greedily assigning values.
2. Initialize `current` to negative infinity.
   - This represents the **last assigned number** in the "distinct" set.
3. Iterate through each number `x`:
   - Calculate the range `[x-k, x+k]` for the number after operations.
   - If `current < x-k`, we can assign `x-k` safely.
   - Else if `current <= x+k`, assign `current` (the smallest available number >= last assigned).
   - Else, skip because we can't assign a distinct value for this number.
4. Update `current` to `assigned + 1` and increase the distinct count.
5. Return the count of distinct numbers after processing all elements.

This greedy approach ensures maximum distinct elements by assigning the smallest valid number in range.

---

# Complexity

- **Time complexity:** $$O(n \log n)$$  
  Sorting the array dominates the time complexity. Iterating through the array is $$O(n)$$.
- **Space complexity:** $$O(1)$$  
  Only a few variables (`current`, `count`, `assigned`) are used.

---

# Code

```python3 []
class Solution:
    def maxDistinctElements(self, nums: List[int], k: int) -> int:
        nums.sort()
        current = float('-inf')
        count = 0

        for x in nums:
            l = x - k
            h = x + k

            if current < l:
                assigned = l
            elif current <= h:
                assigned = current
            else:
                continue

            current = assigned + 1
            count += 1
        return count

```
