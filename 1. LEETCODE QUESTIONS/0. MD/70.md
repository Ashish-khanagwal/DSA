# Intuition

The goal is to find all **unique triplets** in the array that sum to zero.  
Since checking every combination of three numbers would be inefficient ($O(n^3)$), we can improve performance by leveraging **sorting** and the **two-pointer technique** to efficiently explore possible pairs for each fixed number.

---

# Approach

1. **Sort the array** â€” this allows easy skipping of duplicates and the use of the two-pointer method.
2. **Iterate through each element (`nums[i]`)** as a potential first number of a triplet.
   - If `nums[i]` is the same as `nums[i-1]`, skip it to avoid duplicate triplets.
3. For each `nums[i]`, use **two pointers**:
   - `l = i + 1` (left pointer)
   - `r = len(nums) - 1` (right pointer)
4. Compute the sum:  
   `s = nums[i] + nums[l] + nums[r]`
   - If `s == 0`: store the triplet `[nums[i], nums[l], nums[r]]`.
     - Move both pointers while skipping duplicates.
   - If `s < 0`: increment `l` to increase the sum.
   - If `s > 0`: decrement `r` to decrease the sum.
5. Continue until all possible triplets are found.

This method efficiently narrows down valid triplets using the sorted order and avoids duplicates through careful pointer adjustments.

---

# Complexity

- **Time complexity:** $$O(n^2)$$
  - Sorting takes $$O(n \log n)$$, and for each element, the two-pointer scan takes $$O(n)$$.
- **Space complexity:** $$O(1)$$ (ignoring output list)
  - Only a few pointers and variables are used; results are stored separately.

---

# Code

```python3 []
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        nums.sort()
        t = []

        for i in range(len(nums)):
            if i > 0 and nums[i] == nums[i - 1]:
                continue

            l, r = i + 1, len(nums) - 1

            while l < r:
                s = nums[i] + nums[l] + nums[r]

                if s == 0:
                    t.append([nums[i], nums[l], nums[r]])

                    while l < r and nums[l] == nums[l + 1]:
                        l += 1
                    while l < r and nums[r] == nums[r - 1]:
                        r -= 1

                    l += 1
                    r -= 1

                elif s > 0:
                    r -= 1
                else:
                    l += 1
        return t

```
