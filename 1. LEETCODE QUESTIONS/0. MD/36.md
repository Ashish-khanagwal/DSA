# Rotate Array

# Intuition

The problem asks us to **rotate an array to the right by `k` steps**.  
A straightforward way would be to shift elements one by one, but that would take $$O(n \cdot k)$$ time.  
Instead, we can leverage the idea of **reversing parts of the array** to achieve the rotation efficiently.

---

# Approach

1. Compute the effective rotation `k %= n` because rotating by the array’s length `n` results in the same array.
2. Use the **reverse trick**:
   - Reverse the entire array.
   - Reverse the first `` elements.
   - Reverse the remaining `n-k` elements.
3. This rearrangement places the last `k` elements at the front while maintaining the correct order.

---

# Complexity

- **Time complexity:** $$O(n)$$ — each element is reversed exactly once.
- **Space complexity:** $$O(1)$$ — reversal is done in-place with constant extra spac

```
def rotate(nums, k):
  n = len(nums)
  k %= n

  def reverse(start, end):
    while start < end:
      nums[start], nums[end] = nums[end], nums[start]
      start += 1
      end -= 1

  # reverse the whole array
  reverse(0, n-1)

  # reverse till k-1
  reverse(0, k-1)

  # reverse from k till n-1
  reverse(k, n-1)

  print(nums)

rotate([1,2,3,4,5,6,7], 3)
rotate([-1,-100,3,99], 2)
```

'''
THIS METHOD IS GOOD BUT NOT OPTIMAL, T.C = O(n\*k) IN BIG ARRAYS K CAN BE LARGE, WHICH WILL
TAKE AMPLE AMOUNT OF TIME.

```
def rotate(nums, k):
  while k > 0:
    last = nums.pop()
    nums.insert(0, last)
    k -= 1
  print(nums)

rotate([1,2,3,4,5,6,7], 3)
rotate([-1,-100,3,99], 2)
```

'''
