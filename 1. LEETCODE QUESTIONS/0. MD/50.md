# Problem -> Find First and Last Position of Element in Sorted Array

**Problem Link:** [LeetCode - Find First and Last Position of Element in Sorted Array](https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/)

---

## Intuition

The problem asks us to find the first and last positions of a target value in a sorted array.  
A simple linear search would work but would take $$O(n)$$ time. Since the array is sorted, we can use **binary search** to locate the target efficiently.

---

## Approach

1. Perform a standard **binary search** to find any occurrence of the target.
   - If the target is not found, return `[-1, -1]`.

2. Once found, expand outward from the found index:
   - Move left until we find the first occurrence.
   - Move right until we find the last occurrence.

3. Return the pair `[left_index, right_index]`.

---

## Complexity

- **Time Complexity:** $$O(\log n + k)$$
  - $$O(\log n)$$ for the binary search.
  - $$O(k)$$ for scanning left and right in the worst case where `k` is the number of duplicates.  
    In the worst case (all elements are the target), this becomes $$O(n)$$.

- **Space Complexity:** $$O(1)$$  
  We only use a few extra variables.

---

## Code

```python3
class Solution:
    def searchRange(self, nums: List[int], target: int) -> List[int]:
        l, r = 0, len(nums) - 1
        found = -1

        # Step 1: Binary search to find target
        while l <= r:
            m = (l + r) // 2
            if nums[m] == target:
                found = m
                break
            elif nums[m] < target:
                l = m + 1
            else:
                r = m - 1

        if found == -1:
            return [-1, -1]

        # Step 2: Expand left
        l = found
        while l > 0 and nums[l-1] == target:
            l -= 1

        # Step 3: Expand right
        r = found
        while r < len(nums) - 1 and nums[r+1] == target:
            r += 1

        return [l, r]

```
