# Intuition

We want to **group words that are anagrams** together.  
Two words are anagrams if they contain the **same characters in the same counts**.  
So the idea is to convert each word into a **frequency representation** and use it as a key.

---

# Approach

1. **Edge case:** If the input list has 0 or 1 word, return `[strs]`.
2. **Initialize a dictionary (`groups`)** to map each unique frequency key to a list of words.
3. **Iterate through each word** in `strs`:
   - Create a frequency array `freq` of size 26 (for letters 'a' to 'z').
   - Count the occurrences of each character in the word.
   - Convert `freq` to a tuple `key` (so it can be used as a dictionary key).
   - Add the word to the corresponding group in `groups`.
4. **Sort the groups** by their length (optional, based on problem requirement).
5. **Return the grouped anagrams** as a list of lists.

---

# Complexity

- **Time complexity:** $$O(n \cdot k)$$
  - `n` â†’ number of strings, `k` â†’ average length of each string.
  - Counting character frequency for each word takes `O(k)` and storing/retrieving in dict is `O(1)` amortized.
- **Space complexity:** $$O(n \cdot k)$$
  - Storing the frequency arrays and the resulting groups requires extra space proportional to total characters in `strs`.

---

# Code

```python3 []
class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        if len(strs) <= 1:
            return [strs]

        groups = {}

        for s in range(len(strs)):
            freq = [0] * 26

            for ch in strs[s]:
                freq[ord(ch) - ord('a')] += 1

            key = tuple(freq)

            if key in groups:
                groups[key].append(strs[s])
            else:
                groups[key] = [strs[s]]

        sorted_groups = sorted(groups.values(), key = lambda g: len(g))

        return sorted_groups

```
