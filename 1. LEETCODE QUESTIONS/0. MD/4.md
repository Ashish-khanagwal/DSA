# Sqrt(x)

## Intuition

We need to compute the square root of a non-negative integer `x`, but we cannot use built-in power functions like `x ** 0.5`.  
The result must be the **integer part** of the square root (rounded down).

This is a perfect case for **Binary Search** because:

- The square root of `x` must lie between `1` and `x`.
- We can repeatedly check the middle value, square it, and adjust our search range.

---

## Approach

1. Set search boundaries: `L = 1`, `R = x`.
2. While `L <= R`:
   - Compute `M = (L + R) // 2` as the midpoint.
   - If `M * M == x`, return `M` (perfect square).
   - If `M * M < x`, move `L` to `M + 1` (need larger square root).
   - Otherwise, move `R` to `M - 1` (need smaller square root).
3. When the loop ends, return `R`, since it will hold the integer part of the square root.

---

## Complexity

- **Time complexity:** O(log x), because we halve the search space each step.
- **Space complexity:** O(1), only a few variables are used.

---

## Code

```
def mySqrt(x: int) -> int:
    L, R = 1, x
    while L <= R:
        M = (L + R) // 2
        M_squared = M * M

        if M_squared == x:
            return M
        elif M_squared < x:
            L = M + 1
        else:
            R = M - 1
    return R


if __name__ == "__main__":
    print(mySqrt(4))  # Output: 2
    print(mySqrt(8))  # Output: 2
```
