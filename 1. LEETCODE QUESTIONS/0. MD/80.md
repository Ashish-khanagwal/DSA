# Intuition

We are asked to find `k` elements in a **sorted array** that are closest to a given number `x`.  
Because the array is already sorted, we can use a **binary search** approach instead of comparing every element.  
The key observation is that the answer will always be a **continuous subarray of length `k`** — meaning all closest elements are grouped together.

---

# Approach

1. Set the search space between indices `0` and `len(arr) - k` because the last possible starting index for a window of size `k` is `len(arr) - k`.
2. Use binary search:
   - Find the middle point `m`.
   - Compare the distance between `x` and the edges of the window:
     - If `x` is closer to `arr[m + k]`, it means the window should move **right** → set `l = m + 1`.
     - Otherwise, move **left** → set `r = m`.
3. When the binary search ends, `l` will be the starting index of the `k` closest elements.
4. Return the subarray `arr[l:l+k]`.

---

# Complexity

- **Time complexity:** $$O(\log(n - k))$$ — Binary search over possible windows.
- **Space complexity:** $$O(1)$$ — No extra space apart from a few pointers.

---

# Code

```python3 []
class Solution:
    def findClosestElements(self, arr: List[int], k: int, x: int) -> List[int]:
        l, r = 0, len(arr) - k

        while l < r:
            m = (l + r) // 2
            if x - arr[m] > arr[m + k] - x:
                l = m + 1
            else:
                r = m
        return arr[l:l+k]

```
