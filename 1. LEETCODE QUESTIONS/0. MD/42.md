## Intuition

The idea is simple:

- Traverse the linked list node by node.
- Reverse the `next` pointer of each node so it points to the previous node instead of the next one.
- By the time we reach the end, the last node becomes the new head of the reversed list.

---

## Approach

1. Use two pointers:
   - `prev` → initially `None` (this will eventually become the new head).
   - `curr` → starting from the original head.
2. Traverse the list:
   - Temporarily store the next node (`temp = curr.next`).
   - Reverse the current link (`curr.next = prev`).
   - Move `prev` forward (`prev = curr`).
   - Move `curr` forward (`curr = temp`).
3. Continue until `curr` becomes `None`.
4. Return `prev` as the new head.

---

## Complexity

- **Time Complexity:** $$O(n)$$  
  Each node is visited exactly once.

- **Space Complexity:** $$O(1)$$  
  Only a constant number of pointers are used.

---

## Code Implementation

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.nex
```
