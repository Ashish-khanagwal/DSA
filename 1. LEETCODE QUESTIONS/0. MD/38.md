# Remove Duplicates from Sorted Array

---

## Previous Solution

```python
def removeDuplicates(nums: list[int]) -> int:
  r = 0
  seen = set()
  unique = []
  while r < len(nums):
    if nums[r] not in seen:
      seen.add(nums[r])
      unique.append(nums[r])
    r += 1

  for i in range(len(unique)):
    nums[i] = unique[i]

  return len(unique)
```

# Intuition

The first thought is to use a set to keep track of seen numbers and collect unique values.
Then copy those unique values back into the original array.

---

# Approach

1. Traverse the array with pointer `r`.
2. If an element is not in the seen set, add it to both seen and unique.
3. After traversal, overwrite the first part of nums with elements from unique.
4. Return the length of unique as the count of unique numbers.

---

# Complexity

- **Time complexity:** $$O(n)$$ - we traverse the list once and then copy unique values back.
- **Space complexity:** $$O(n)$$ — extra space for seen and unique.

---

# Why It’s Not Optimal

Although it works, it does not meet the in-place requirement of the problem because it uses additional space proportional to the input size.
The problem specifically asks for a solution with O(1) extra space, making this approach suboptimal.

# Current (Optimal) Solution

```python
def removeDuplicates(nums: list[int]) -> int:
    if not nums:
        return 0

    i = 0
    for j in range(1, len(nums)):
        if nums[j] != nums[i]:
            i += 1
            nums[i] = nums[j]

    return i + 1
```

# Intuition

The array is already sorted, so all duplicates must appear **next to each other**.  
This means we can use a two-pointer approach: one pointer keeps track of the position of the last unique element, and the other scans the array.

---

# Approach

1. If the array is empty, return `0` (no unique elements).
2. Initialize pointer `i = 0` to mark the position of the last unique element.
3. Iterate `j` from index `1` to the end:
   - If `nums[j] != nums[i]`, it means a new unique element is found.
   - Move `i` one step forward and set `nums[i] = nums[j]`.
4. At the end, the first `i + 1` elements of `nums` are the unique values in sorted order.
5. Return `i + 1` as the count of unique elements.

---

# Complexity

- **Time complexity:** $$O(n)$$ — single pass through the array.
- **Space complexity:** $$O(1)$$ — in-place modification without extra space.
