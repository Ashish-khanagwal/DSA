# Intuition

We are asked to find, for each spell, the number of potions that when multiplied with it meet or exceed a given `success` threshold.  
Since we need to do this for every spell efficiently, **sorting the potions** and using **binary search** is a natural approach.

---

# Approach

1. **Sort** the `potions` array in ascending order.
2. For each spell `s` in `spells`:
   - Initialize `l = 0` and `r = len(potions) - 1`.
   - Use binary search to find the **first potion index `idx`** such that `s * potions[idx] >= success`.
     - If `s * potions[m] >= success`, move `r = m - 1` and update `idx = m`.
     - Otherwise, move `l = m + 1`.
   - The number of successful pairs for this spell is `len(potions) - idx`.
3. Append the count to the result list.
4. Return the final list after processing all spells.

This approach avoids the naive `O(n*m)` solution and leverages sorting and binary search for efficiency.

---

# Complexity

- **Time Complexity:** $$O(n \log m + m \log m)$$
  - Sorting potions: $$O(m \log m)$$
  - Binary search for each spell: $$O(n \log m)$$

- **Space Complexity:** $$O(1)$$ (excluding output)

---

# Code

```python3 []
class Solution:
    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:
        potions.sort()
        res = []

        for s in spells:
            idx = len(potions)
            l, r = 0, len(potions) - 1
            while l <= r:
                m = (l + r) // 2

                if s * potions[m] >= success:
                    r = m - 1
                    idx = m
                else:
                    l = m + 1

            res.append(len(potions) - idx)
        return res

```
