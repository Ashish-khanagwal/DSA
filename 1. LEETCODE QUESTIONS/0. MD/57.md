# Intuition

The matrix is sorted in a special way:

- Each row is sorted in ascending order.
- The first element of each row is greater than the last element of the previous row.

This allows us to **treat the 2D matrix as a 1D sorted array** and use **binary search** instead of searching row by row.

---

# Approach

1. Let `m` be the number of rows and `n` the number of columns.
2. Map the 2D index `(row, col)` to a 1D index:
   - 1D index `mid` corresponds to `row = mid // n` and `col = mid % n`.
3. Use binary search:
   - Start with `l = 0` and `r = m * n - 1`.
   - Compute `mid = (l + r) // 2` and convert it to 2D indices.
   - Compare `matrix[row][col]` with `target`:
     - If equal → return `True`.
     - If greater → search left half (`r = mid - 1`).
     - If smaller → search right half (`l = mid + 1`).
4. If not found after the loop ends, return `False`.

---

# Complexity

- **Time Complexity:** $$O(\log(m \cdot n))$$
  - Binary search on the virtual 1D array of size `m*n`.
- **Space Complexity:** $$O(1)$$
  - Only constant extra space is used for pointers and calculations.

---

# Code

```python3 []
class Solution:
    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:
        m, n = len(matrix), len(matrix[0])
        l, r = 0, (m * n) - 1
        while l <= r:
            mid = (l + r) // 2
            row = mid // n
            col = mid % n
            value = matrix[row][col]
            if value == target:
                return True
            elif value > target:
                r = mid - 1
            else:
                l = mid + 1
        return False

```
