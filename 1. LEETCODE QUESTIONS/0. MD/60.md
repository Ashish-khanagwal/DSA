# Intuition

We are asked to summarize consecutive ranges in a sorted array of unique integers.  
If numbers appear consecutively, we can compress them into a single range `"start->end"`.  
If a number appears alone without consecutive neighbors, we just add it as a single element.

---

# Approach

1. Initialize an empty list `l` to store the ranges.
2. If the array is empty, return the empty list immediately.
3. Use a variable `start` to mark the beginning of the current range.
4. Iterate through the array:
   - For each number, check if it is the **end of a consecutive sequence**:
     - Either it is the **last element** in the list, or
     - The next number is **not consecutive** (i.e., `nums[i+1] != nums[i] + 1`).
   - If `start == nums[i]`, it means the range has only one element, so add just `str(start)`.
   - Otherwise, append the range as `"start->nums[i]"`.
   - If more elements remain, set the next number as the new `start`.
5. Return the list of ranges.

---

# Complexity

- **Time Complexity:** $$O(n)$$
  - We process each element exactly once.

- **Space Complexity:** $$O(1)$$ (ignoring the output list)
  - We only use a few variables, but the output list depends on the result.

---

# Code

```python3 []
class Solution:
    def summaryRanges(self, nums: List[int]) -> List[str]:
        l = []
        if not nums:
            return l

        start = nums[0]
        for i in range(len(nums)):
            if i == len(nums) - 1 or nums[i+1] != nums[i] + 1:
                if start == nums[i]:
                    l.append(str(start))
                else:
                    l.append(f"{start}->{nums[i]}")
                if i < len(nums) - 1:
                    start = nums[i+1]
        return l

```
