# üßÆ Problem 18 ‚Äî 4Sum

**Link:** [Leetcode 18 ‚Äî 4Sum](https://leetcode.com/problems/4sum/)

---

## üß† Intuition

The problem asks us to find all unique **quadruplets** `[a, b, c, d]` in an array such that:

`a + b + c + d == target`

At first glance, this looks similar to the **3Sum problem**, but instead of finding triplets, we now need **four numbers** that satisfy the condition.

A naive approach would involve checking every possible quadruplet ‚Äî which is **O(n‚Å¥)** and infeasible for `n ‚â§ 200`.

However, we can extend the **3Sum + two-pointer** idea:

1. Sort the array to make it easier to skip duplicates.
2. Fix two numbers (`i` and `j`) using two nested loops.
3. Use the **two-pointer** method (`l` and `r`) for the remaining two numbers.
4. Adjust pointers based on the current sum relative to the target.

---

## üß© Approach

### Step 1: Sort the array

Sorting allows efficient duplicate removal and makes two-pointer traversal possible.

### Step 2: Use two nested loops

- First loop fixes the first number (`nums[i]`).
- Second loop fixes the second number (`nums[j]`).

For each pair `(i, j)`, we will search for two more numbers that complete the quadruplet.

### Step 3: Two-pointer search

- Initialize `l = j + 1` and `r = len(nums) - 1`.
- Compute the sum:

`s = nums[i] + nums[j] + nums[l] + nums[r]`

- If `s == target`, we found a valid quadruplet.
- If `s < target`, move `l` forward to increase the sum.
- If `s > target`, move `r` backward to decrease the sum.

### Step 4: Skip duplicates

After finding a quadruplet, move pointers `l` and `r` past duplicates to avoid repeating results.
Similarly, skip duplicate `i` and `j` values to avoid redundant processing.

### Step 5: Return the result

Store all valid quadruplets and return them at the end.

---

## üß± Code Implementation

```python
from typing import List

def fourSum(nums: List[int], target: int) -> List[List[int]]:
  nums.sort()
  t = []

  for i in range(len(nums)):
      if i > 0 and nums[i] == nums[i - 1]:
          continue

      for j in range(i + 1, len(nums)):
          if j > i + 1 and nums[j] == nums[j - 1]:
              continue

          l, r = j + 1, len(nums) - 1
          while l < r:
              s = nums[i] + nums[j] + nums[l] + nums[r]

              if s == target:
                  t.append([nums[i], nums[j], nums[l], nums[r]])

                  # Skip duplicates for l and r
                  while l < r and nums[l] == nums[l + 1]:
                      l += 1
                  while l < r and nums[r] == nums[r - 1]:
                      r -= 1

                  l += 1
                  r -= 1

              elif s < target:
                  l += 1
              else:
                  r -= 1

  return t


# ‚úÖ Test Cases
print(fourSum([1, 0, -1, 0, -2, 2], 0))
print(fourSum([2, 2, 2, 2, 2], 8))
```
