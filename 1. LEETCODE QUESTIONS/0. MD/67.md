# Intuition

We want to check if `s2` contains a permutation of `s1`.  
A permutation is essentially a **rearrangement of characters**, so the key is to match character **frequencies** rather than exact positions.

---

# Approach

1. **Edge case:** If `len(s1) > len(s2)`, return `False` immediately.
2. **Build a frequency map** (`hashmap`) for all characters in `s1`.
3. **Sliding window:** Initialize a window of size `len(s1)` over `s2` and maintain a frequency map (`window_map`) for this window.
4. **Compare maps:**
   - If `window_map == hashmap`, then the current window is a permutation of `s1`, return `True`.
5. **Slide the window** one character at a time:
   - Remove the count of the character going out of the window (`s2[i-n]`). Delete the key if its count becomes 0.
   - Add the count of the new character entering the window (`s2[i]`).
   - Check again if `window_map == hashmap`.
6. If no matching window is found after sliding through the entire string, return `False`.

This approach efficiently checks all substrings of size `len(s1)` in `s2` without generating all permutations explicitly.

---

# Complexity

- **Time Complexity:** $$O(m)$$
  - Building maps takes $$O(n)$$ and sliding the window over `s2` takes $$O(m-n+1) \approx O(m)$$.
  - Comparing dictionaries is $$O(1)$$ in practice for small alphabets (constant 26 for lowercase letters).

- **Space Complexity:** $$O(1)$$
  - Only need fixed-size frequency maps of letters, so space is effectively constant.

---

# Code

```python3 []
class Solution:
    def checkInclusion(self, s1: str, s2: str) -> bool:
        n = len(s1)
        m = len(s2)

        if n > m:
            return False

        hashmap = {}
        for s in s1:
            hashmap[s] = hashmap.get(s, 0) + 1

        window_map = {}
        for i in range(n):
            window_map[s2[i]] = window_map.get(s2[i], 0) + 1

        if window_map == hashmap:
            return True

        for i in range(n, m):

```
