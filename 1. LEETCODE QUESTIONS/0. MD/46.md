# Problem -> Valid Perfect Square

**Problem Link:** [LeetCode - Valid Perfect Square](https://leetcode.com/problems/valid-perfect-square/)

---

## Intuition

We need to check if a given number is a **perfect square**.  
The naive way would be to try squaring numbers one by one until we reach or exceed `num`, but that would be inefficient for large inputs.

Since the square of numbers grows monotonically, we can use **Binary Search** over the range `[1, num]` to efficiently determine whether such an integer exists.

---

## Approach

1. Initialize search range: `l = 1`, `r = num`.
2. Use **Binary Search**:
   - Compute mid `M = (l + r) // 2`.
   - Compute `M_squared = M * M`.
   - If `M_squared == num`, return `True`.
   - If `M_squared < num`, move the left boundary up: `l = M + 1`.
   - Otherwise, move the right boundary down: `r = M - 1`.
3. If no perfect square is found, return `False`.

---

## Complexity

- **Time Complexity:** $$O(\log n)$$  
  Binary Search halves the range at each step.

- **Space Complexity:** $$O(1)$$  
  Only a few variables are used, no extra data structures.

---

## Code

```python3
class Solution:
    def isPerfectSquare(self, num: int) -> bool:
        l = 1
        r = num
        while l <= r:
            M = (l + r) // 2
            M_squared = M * M
            if M_squared == num:
                return True
            elif M_squared < num:
                l = M + 1
            else:
                r = M - 1
        return False

```
