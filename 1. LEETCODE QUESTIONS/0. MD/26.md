# Intuition

The problem asks whether there are duplicate elements in the array such that their indices are at most `k` apart.  
The first thought is to use a **sliding window** of size `k` while tracking elements inside it. If the same number appears again within the window, we return `True`.

# Approach

1. Use a **set** to keep track of elements inside the current window of size `k`.
2. Iterate through the array with two pointers:
   - `r` (right pointer) → current index.
   - `l` (left pointer) → start of the window.
3. For each element:
   - If window size exceeds `k`, remove the leftmost element (`nums[l]`) from the set and move `l`.
   - If the current number already exists in the set, return `True`.
   - Otherwise, add it to the set.
4. If no duplicates found after iteration, return `False`.

# Complexity

- **Time complexity:** $$O(n)$$ — each element is added and removed from the set at most once.
- **Space complexity:** $$O(k)$$ — the set holds at most `k` elements.

---

# Code

```
class Solution:
    def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:
        seen = set()
        l = 0

        for r in range(len(nums)):
            if r - l > k:
                seen.remove(nums[l])
                l += 1
            if nums[r] in seen:
                return True
            seen.add(nums[r])
        return False
```
