# Intuition

The array is sorted but **rotated at some pivot**, which means it’s made up of two sorted halves.  
A normal binary search doesn’t directly work because the mid element might not clearly tell whether to go left or right.  
However, we can still apply a modified binary search if we **detect which half is sorted** at every step.

---

# Approach

1. Use **binary search** with two pointers: `l` (left) and `r` (right).
2. Compute the middle index `m = (l + r) // 2`.
3. If `nums[m] == target`, return `m` — we found the target.
4. Otherwise, determine which half of the array is **sorted**:
   - If `nums[l] <= nums[m]`, the **left half is sorted**.
     - Check if the target lies between `nums[l]` and `nums[m]`.  
       If yes → move `r = m - 1`, else → move `l = m + 1`.
   - Else, the **right half is sorted**.
     - Check if the target lies between `nums[m]` and `nums[r]`.  
       If yes → move `l = m + 1`, else → move `r = m - 1`.
5. If the loop ends without finding the target, return `-1`.

This approach ensures we eliminate half the search space at each step, just like normal binary search.

---

# Complexity

- **Time complexity:** $$O(\log n)$$  
  Because at each iteration, we reduce the search space by half.
- **Space complexity:** $$O(1)$$  
  We only use a few variables (`l`, `r`, `m`) for the search.

---

# Code

```python3 []
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        l, r = 0, len(nums) - 1
        while l <= r:
            m = (l + r) // 2

            if nums[m] == target:
                return m

            # Left half is sorted
            if nums[l] <= nums[m]:
                if nums[l] <= target < nums[m]:
                    r = m - 1
                else:
                    l = m + 1
            # Right half is sorted
            else:
                if nums[m] < target <= nums[r]:
                    l = m + 1
                else:
                    r = m - 1
        return -1

```
