# Intuition

We need to find the longest subarray containing only `1`s if we are allowed to flip at most `k` zeros into ones.  
This is a classic **sliding window problem** where we dynamically adjust the window size based on the number of zeros flipped.

---

# Approach

1. Use two pointers `left` and `right` to represent the current window.
2. Traverse the array with `right`:
   - If `nums[right] == 0`, increment `flip` (representing a zero being flipped).
3. If at any point the number of flipped zeros (`flip`) exceeds `k`, shrink the window from the left:
   - Move `left` forward until `flip <= k`.
   - If the element at `left` is `0`, decrement `flip`.
4. At each step, update the maximum window size (`max_len`) as `right - left + 1`.
5. Return `max_len` as the longest subarray length.

---

# Complexity

- **Time Complexity:** $$O(n)$$  
  Each element is processed at most twice (once by `right` and once by `left`).

- **Space Complexity:** $$O(1)$$  
  Only a few integer variables are used.

---

# Code

```python3 []
class Solution:
    def longestOnes(self, nums: List[int], k: int) -> int:
        left = 0
        max_len = float('-inf')
        flip = 0

        for right in range(len(nums)):
            if nums[right] == 0:
                flip += 1

            while flip > k:
                if nums[left] == 0:
                    flip -= 1
                left += 1
            max_len = max(max_len, right - left + 1)
        return max_len

```
