# Intuition

The problem is about **adding one** to a number represented as a list of digits.  
For example, `[1, 2, 3]` represents `123`, and adding one gives `[1, 2, 4]`.  
The tricky part is when there’s a **carry-over**, like `[9, 9] → [1, 0, 0]`.  
So, the idea is to handle carry propagation correctly from the **least significant digit** (rightmost) to the **most significant digit** (leftmost).

---

# Approach

1. Start by adding 1 to the **last digit**.
2. Traverse the list **backwards** to handle possible carries:
   - If a digit becomes 10, set it to 0.
   - Add 1 to the previous digit.
   - If the carry reaches the start (e.g., `[9, 9] → [1, 0, 0]`), insert `1` at the beginning.
3. Return the updated digits list.

This mimics how we add numbers manually — starting from the rightmost side and carrying over if necessary.

---

# Complexity

- **Time complexity:** $$O(n)$$  
  We may need to traverse all digits once in the worst case (like `[9, 9, 9]`).
- **Space complexity:** $$O(1)$$  
  We modify the list in place, except for one potential new digit insertion at the start.

---

# Code

```python3 []
class Solution:
    def plusOne(self, digits: List[int]) -> List[int]:
        digits[-1] += 1

        for i in range(len(digits) - 1, -1, -1):
            if digits[i] == 10:
                digits[i] = 0
                if i == 0:
                    digits.insert(0, 1)
                else:
                    digits[i-1] += 1

        return digits

```
