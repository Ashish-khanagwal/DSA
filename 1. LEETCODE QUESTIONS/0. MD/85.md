# Intuition

The problem asks for the total number of subarrays whose sum equals a given value `k`.  
A **naive approach** would check all subarrays (using nested loops), but that would be inefficient with $$O(n^2)$$ time complexity.  
Instead, we can use the **prefix sum** concept along with a **hashmap** to efficiently keep track of subarray sums as we traverse the array.

---

# Approach

1. **Prefix Sum Concept:**
   - The prefix sum at index `i` is the sum of all elements from the start up to index `i`.
   - If the difference between two prefix sums equals `k`, it means the elements between those two indices form a subarray with sum `k`.  
     Mathematically, if `prefix_sum[j] - prefix_sum[i] = k`, then the subarray `(i+1...j)` has sum `k`.

2. **Hashmap Tracking:**
   - Maintain a hashmap (`prefix_map`) that stores the frequency of each prefix sum encountered.
   - Initialize with `{0: 1}` because a subarray starting from index 0 could itself have sum `k`.
   - For each element:
     - Update the current prefix sum.
     - Check if `prefix_sum - k` exists in the hashmap.
       - If yes, add its frequency to the count (since each occurrence represents a valid subarray).
     - Update the frequency of the current prefix sum in the hashmap.

3. **Result:**
   - After traversing all elements, `count` will store the total number of subarrays whose sum equals `k`.

---

# Complexity

- **Time complexity:** $$O(n)$$ — We traverse the array once and perform constant-time hashmap lookups/updates.
- **Space complexity:** $$O(n)$$ — In the worst case, all prefix sums are unique and stored in the hashmap.

---

# Code

```python3 []
class Solution:
    def subarraySum(self, nums: List[int], k: int) -> int:
        count = 0
        prefix_sum = 0
        prefix_map = {0: 1}

        for num in nums:
            prefix_sum += num
            if prefix_sum - k in prefix_map:
                count += prefix_map[prefix_sum - k]
            prefix_map[prefix_sum] = prefix_map.get(prefix_sum, 0) + 1

        return count

```
