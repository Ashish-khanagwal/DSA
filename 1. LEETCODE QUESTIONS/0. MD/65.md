# Intuition

We are asked to find the length of the longest substring where we can replace at most `k` characters to make all characters the same.  
This is similar to a **sliding window problem** where we dynamically adjust the window size based on the allowed replacements.

---

# Approach

1. Use two pointers `left` and `right` to define the sliding window.
2. Use a `count` dictionary to track the frequency of characters within the current window.
3. Keep track of the maximum frequency `max_freq` of any single character in the window.
4. Expand the window by moving `right`:
   - Increment `count[s[right]]`.
   - Update `max_freq` if necessary.
5. If the number of characters to change `(right - left + 1) - max_freq` exceeds `k`, shrink the window from the left:
   - Decrement `count[s[left]]` and move `left` forward.
6. Update `max_len` at each step as the maximum window length satisfying the replacement condition.
7. Return `max_len`.

---

# Complexity

- **Time Complexity:** $$O(n)$$  
  Each character is processed at most twice (once when entering the window and once when leaving).

- **Space Complexity:** $$O(1)$$  
  There are at most 26 characters in the English alphabet, so the dictionary has constant space.

---

# Code

```python3 []
from collections import defaultdict

class Solution:
    def characterReplacement(self, s: str, k: int) -> int:
        left = 0
        count = defaultdict(int)
        max_len = 0
        max_freq = 0

        for right in range(len(s)):
            count[s[right]] += 1
            max_freq = max(max_freq, count[s[right]])

            while (right-left+1) - max_freq > k:
                count[s[left]] -= 1
                left += 1
            max_len = max(max_len, right-left+1)
        return max_len

```
