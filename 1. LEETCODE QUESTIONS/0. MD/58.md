# Intuition

The problem is about reusing empty bottles to get new full bottles of water.  
Initially, you have `numBottles` full bottles. Every time you finish drinking, you collect empty bottles. Once you gather at least `numExchange` empty bottles, you can trade them for new full bottles. The process continues until you no longer have enough empty bottles to exchange.

So, the task is to **simulate this exchange process** and count how many bottles of water you can drink in total.

---

# Approach

1. Start with `maxWaterBottles = numBottles` since you can immediately drink all the given full bottles.
2. Track the number of empty bottles: initially equal to `numBottles`.
3. While you have enough empty bottles (`empty >= numExchange`):
   - Exchange empty bottles to get new full ones: `newBottles = empty // numExchange`.
   - Add these new bottles to the total count of water bottles drunk.
   - Update the empty bottles: the newly obtained empty bottles (`newBottles`) plus leftover bottles (`empty % numExchange`).
4. Continue until you cannot exchange anymore.
5. Return the total `maxWaterBottles`.

---

# Complexity

- **Time Complexity:** $$O(\log_{numExchange}(numBottles))$$
  - In each iteration, the number of empty bottles decreases significantly (division by `numExchange`), so the loop runs logarithmically relative to `numBottles`.
- **Space Complexity:** $$O(1)$$
  - Only a few variables are used for tracking counts.

---

# Code

```python3 []
class Solution:
    def numWaterBottles(self, numBottles: int, numExchange: int) -> int:
        maxWaterBottles = numBottles
        empty = numBottles

        while empty >= numExchange:
            newBottles = empty // numExchange
            maxWaterBottles += newBottles
            empty = newBottles + (empty % numExchange)
        return maxWaterBottles

```
