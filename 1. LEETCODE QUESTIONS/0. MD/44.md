# Problem -> Design HashMap

**Problem Link:** [LeetCode - Design HashMap](https://leetcode.com/problems/design-hashmap/)

---

## Intuition

The task is to implement a **HashMap** without using built-in hash table libraries.  
A hash map stores `(key, value)` pairs and provides operations like `put`, `get`, and `remove` in **average O(1)** time.

Since Python already provides dictionaries, we simulate a hash map by using:

- A **fixed-size array (`table`)** where each slot stores a bucket.
- **Chaining with lists** to handle collisions (multiple keys hashing to the same index).

---

## Approach

1. **Hash Function**:  
   Compute an index for a given key using `key % size`.
   - Here, `size = 1000` is chosen as a base size for the hash table.

2. **Put (Insert/Update)**:
   - Hash the key to find the correct bucket.
   - If the key already exists, update its value.
   - Otherwise, append `(key, value)` to the bucket.

3. **Get (Retrieve)**:
   - Hash the key to locate the bucket.
   - Search the bucket for the key.
   - If found, return the value; otherwise, return `-1`.

4. **Remove (Delete)**:
   - Hash the key to locate the bucket.
   - Search for the key inside the bucket.
   - If found, delete the entry.

This approach ensures average constant-time operations, but in the worst case (all keys in one bucket), performance degrades to O(n).

---

## Complexity

- **Time Complexity:**
  - Average: $$O(1)$$ for `put`, `get`, and `remove`.
  - Worst case: $$O(n)$$ if many keys collide in the same bucket.

- **Space Complexity:** $$O(n)$$
  - We store all inserted key-value pairs in the hash map.

---

## Code

```python3
class MyHashMap:

    def __init__(self):
        self.size = 1000
        self.table = [[] for _ in range(self.size)]

    def _hash(self, key):
        return key % self.size

    def put(self, key: int, value: int) -> None:
        index = self._hash(key)
        for pair in self.table[index]:
            if pair[0] == key:
                pair[1] = value
                return
        self.table[index].append([key, value])

    def get(self, key: int) -> int:
        index = self._hash(key)
        for pair in self.table[index]:
            if pair[0] == key:
                return pair[1]
        return -1

    def remove(self, key: int) -> None:
        index = self._hash(key)
        for i, pair in enumerate(self.table[index]):
            if pair[0] == key:
                del self.table[index][i]
                return


# Example usage:
# obj = MyHashMap()
# obj.put(1, 10)
# print(obj.get(1))  # Output: 10
# obj.remove(1)
# print(obj.get(1))  # Output: -1
```
