# First Missing Positive - Deep Explanation

## Problem Intuition

We are asked to find the **smallest positive integer missing** from an unsorted array `nums`. The constraints are:

- **O(n)** time complexity.
- **O(1)** auxiliary space.

Key insight: The **smallest missing positive integer** must lie in the range `[1, n+1]`, where `n` is the length of the array:

- If all numbers `1` through `n` are present, the answer is `n + 1`.
- Otherwise, the first gap in numbers from `1` to `n` gives the missing positive.

This leads us to a **cyclic placement approach** where each number is placed at its "home index" if it falls within `[1, n]`.

---

## Step 1: Rearrangement (Cyclic Placement)

**Goal:** Place each number `x` in its correct position `index = x - 1` if `1 <= x <= n`.

**How it works:**

1. Iterate through each index `i` in the array.
2. For `nums[i]`, while it is a valid number (between 1 and n) and not in its correct position (`nums[i] != nums[nums[i]-1]`), swap it to its correct index.
3. Repeat until the current index holds a correct number or an invalid number.

**Example:**

`nums = [3, 4, -1, 1]`

- i = 0, nums[0] = 3 → correct index = 2 → swap → `nums = [-1, 4, 3, 1]`
- i = 0, nums[0] = -1 → invalid, move on
- i = 1, nums[1] = 4 → correct index = 3 → swap → `nums = [-1, 1, 3, 4]`
- i = 1, nums[1] = 1 → correct index = 0 → swap → `nums = [1, -1, 3, 4]`
- i = 2, nums[2] = 3 → correct index = 2 → already correct
- i = 3, nums[3] = 4 → correct index = 3 → already correct

**After rearrangement:** `[1, -1, 3, 4]`

This ensures all numbers 1 to n are either at their correct indices or ignored if invalid.

---

## Step 2: Finding the Missing Positive

**Goal:** Scan the rearranged array to find the first mismatch.

**How it works:**

1. Iterate through each index `i` from 0 to n-1.
2. If `nums[i] != i + 1`, the missing positive is `i + 1`.
3. If all indices match their correct numbers, the missing positive is `n + 1`.

**Example continued:**

`nums = [1, -1, 3, 4]`

- i = 0 → nums[0] = 1 ✅
- i = 1 → nums[1] = -1 ❌ → smallest missing positive = 2 ✅

`nums = [1, 2, 0]`

- i = 0 → nums[0] = 1 ✅
- i = 1 → nums[1] = 2 ✅
- i = 2 → nums[2] = 0 ❌ → smallest missing positive = 3 ✅

**Key idea:** Each index `i` corresponds to the number `i+1`. The first mismatch gives the answer.

---

## Time Complexity

- **Cyclic Placement:** Each number is swapped at most once into its correct position → `O(n)`
- **Scan for missing positive:** Single linear scan → `O(n)`
- **Total:** `O(n)`

## Space Complexity

- No extra arrays, sets, or hashmaps are used.
- Only a few variables for indices are used.
- **Auxiliary space:** `O(1)`

---

## Summary

1. **Intuition:** The smallest missing positive lies in `[1, n+1]`. Place numbers in their "home" indices to directly map values to indices.
2. **Rearrangement:** Swap each valid number into its correct index using a while-loop (cyclic placement).
3. **Finding:** Scan the array for the first index mismatch; that gives the missing positive.
4. **Complexity:** Linear time and constant extra space.

This approach elegantly solves the problem in-place and efficiently.

```
from typing import List

def firstMissingPositive(nums: List[int]) -> int:
    n = len(nums)

    # Step 1: Place each number in its correct index (cyclic placement)
    for i in range(n):
        while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]:
            correct_idx = nums[i] - 1
            nums[i], nums[correct_idx] = nums[correct_idx], nums[i]

    # Step 2: Find the first index where the value is not i + 1
    for i in range(n):
        if nums[i] != i + 1:
            return i + 1

    # Step 3: If all numbers 1…n are in place, return n + 1
    return n + 1

# Test cases
print(firstMissingPositive([1,2,0]))           # Output: 3
print(firstMissingPositive([3,4,-1,1]))        # Output: 2
print(firstMissingPositive([7,8,9,11,12]))     # Output: 1
```
