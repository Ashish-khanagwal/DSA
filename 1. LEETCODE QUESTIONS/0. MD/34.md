# Valid Palindrome II

# Intuition

A palindrome reads the same forward and backward.  
The twist in this problem is that we are allowed to **remove at most one character** to still form a palindrome.  
The key observation is that as soon as we encounter a mismatch, we can try skipping either the left or the right character and check if the remaining substring is a palindrome.

---

# Approach

1. Use two pointers `l` and `r` starting from the beginning and end of the string.
2. Move inward while characters match.
3. If a mismatch occurs:
   - Check if the substring without the left character (`s[l+1:r+1]`) is a palindrome, **OR**
   - Check if the substring without the right character (`s[l:r]`) is a palindrome.
   - If either works, return `True`.
4. If no mismatches are found, the string is already a palindrome.
5. Return `True`.

---

# Complexity

- **Time complexity:** $$O(n)$$ — each character is compared at most twice.
- **Space complexity:** $$O(1)$$ — only a few pointers are used.

---

# Code

```python3 []
class Solution:
    def validPalindrome(self, s: str) -> bool:
        if s == "" or len(s) == 1:
            return True

        def is_Palindrome(l, r):
            while l < r:
                if s[l] != s[r]:
                    return False
                l += 1
                r -= 1
            return True

        l, r = 0, len(s) - 1
        while l < r:
            if s[l] != s[r]:
                return is_Palindrome(l+1, r) or is_Palindrome(l, r-1)
            l += 1
            r -= 1
        return True
```
