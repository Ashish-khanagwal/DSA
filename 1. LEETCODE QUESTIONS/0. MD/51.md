# Problem -> Single Element in a Sorted Array

**Problem Link:** [LeetCode - Single Element in a Sorted Array](https://leetcode.com/problems/single-element-in-a-sorted-array/)

---

## Intuition

In a sorted array where every element appears twice except one, the **unique element must break the pairing pattern**.  
Normally, pairs are aligned such that:

- the first of the pair is at an even index,
- the second of the pair is at an odd index.

Once the single element appears, this pairing shifts. We can exploit this property with **binary search**.

---

## Approach

1. Use **binary search** with two pointers `l` and `r`.
2. At each step, calculate the middle index `m`.
   - If `m` is odd, decrement it by 1 to ensure `m` is always at the start of a pair.
3. Compare `nums[m]` with `nums[m+1]`:
   - If they are equal, it means the single element lies on the right side → move `l` to `m+2`.
   - If they are not equal, it means the single element lies on the left side (including `m`) → move `r` to `m`.
4. When `l == r`, return `nums[l]` as the single element.

---

## Complexity

- **Time Complexity:** $$O(\log n)$$  
  Because we use binary search to repeatedly cut the search space in half.

- **Space Complexity:** $$O(1)$$  
  Only a few pointers and variables are used.

---

## Code

```python3
class Solution:
    def singleNonDuplicate(self, nums: List[int]) -> int:
        l, r = 0, len(nums) - 1
        while l < r:
            m = (l + r) // 2
            if m % 2 == 1:
                m -= 1
            if nums[m] == nums[m+1]:
                l = m + 2
            else:
                r = m
        return nums[l]

```
