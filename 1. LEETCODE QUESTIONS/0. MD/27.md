# Intuition

The problem asks us to find the index of a target value in a sorted array.  
Since the array is sorted, instead of checking every element linearly, we can use the **binary search technique** to cut down the search space in half each time.

# Approach

1. Initialize two pointers:
   - `left = 0` (start of the array)
   - `right = len(nums) - 1` (end of the array)
2. While `left <= right`:
   - Compute `mid = (left + right) // 2`.
   - If `nums[mid] == target`, return `mid`.
   - If `nums[mid] < target`, search in the right half (`left = mid + 1`).
   - Otherwise, search in the left half (`right = mid - 1`).
3. If the loop ends and no match is found, return `-1`.

# Complexity

- **Time complexity:** $$O(\log n)$$ — search space is halved each iteration.
- **Space complexity:** $$O(1)$$ — only a few variables are used.

# Code

```python3 []
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        left = 0
        right = len(nums) - 1
        while left <= right:
            mid = (left + right) // 2
            if nums[mid] == target:
                return mid
            elif nums[mid] < target:
                left = mid + 1
            else:
                right = mid - 1
        return -1
```
