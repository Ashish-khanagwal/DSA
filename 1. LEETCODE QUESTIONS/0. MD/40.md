# Sort Colors (Dutch National Flag Problem)

## 1. Intuition

We are asked to sort an array containing only 3 values (`0 â†’ red`, `1 â†’ white`, `2 â†’ blue`) **in-place**.

- A normal sorting algorithm (like quicksort or mergesort) would take **O(n log n)**.
- Counting sort would take **O(n)** but needs extra memory.
- Since there are only **3 categories**, we can solve this in **one pass and in-place**.

ðŸ‘‰ This is a classic **Dutch National Flag Problem**:

- Move all `0`s to the left,
- Move all `2`s to the right,
- Leave all `1`s in the middle.

---

## 2. Why is this Efficient?

- **Single pass (O(n))**: Each element is processed at most once.
- **In-place (O(1))**: No extra memory needed.
- Leverages the fact that there are only **3 unique values**.

This is better than counting sort (extra space) or general sorting (slower).

---

## 3. Pseudo Code

```text
Initialize:
    l = 0      # left boundary (for 0s)
    r = n - 1  # right boundary (for 2s)
    i = 0      # current pointer

While i <= r:
    If nums[i] == 0:
        Swap(nums[i], nums[l])
        l += 1
        i += 1
    Else if nums[i] == 2:
        Swap(nums[i], nums[r])
        r -= 1
        # do not increment i, because new nums[i] needs checking
    Else: # nums[i] == 1
        i += 1
```

## 4. Code

```python
def sortColors(nums):
  l, r = 0, len(nums)-1
  i = 0

  while i <= r:
    if nums[i] == 0:
      nums[i], nums[l] = nums[l], nums[i]
      l += 1
    elif nums[i] == 2:
      nums[i], nums[r] = nums[r], nums[i]
      r -= 1
      i -= 1
    i += 1
  return nums

print(sortColors([2,0,2,1,1,0]))
print(sortColors([2,0,1]))
```
