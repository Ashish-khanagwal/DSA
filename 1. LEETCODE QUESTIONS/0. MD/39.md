# Misraâ€“Gries vs Hashmap-Based Implementation

## ðŸ”¹ Problem Context

We want to find all elements in an array `nums` that occur **more than n/k times**.  
Two approaches exist:

1. **Classical Misraâ€“Gries Algorithm**
2. **Hashmap-based implementation (with dictionary rebuilding)**

---

## ðŸ”¹ Hashmap-Based Implementation

### Steps:

1. Use a `defaultdict` to store element frequencies.
2. If more than `k-1` candidates exist:
   - Decrement all counts.
   - Remove candidates with count 0.
3. After processing, verify which candidates occur more than `n/k` times.

### Complexity

- **Time Complexity**
  - Incrementing counts â†’ `O(1)` average per element.
  - Rebuilding dictionary â†’ `O(k)` when needed.
  - Verification step: `nums.count(n)` for up to `k-1` elements â†’ `O(nk) = O(n)`.
  - âœ… Overall: **O(n)**

- **Space Complexity**
  - Stores at most `k-1` candidates â†’ **O(k)**

```python
from collections import defaultdict
def majorityElement(nums):
  k = 3
  count = defaultdict(int)
  for n in nums:
    count[n] += 1

    if len(count) <= k-1:
      continue

    new_count = defaultdict(int)
    for n, c in count.items():
      if c > 1:
        new_count[n] = c - 1
    count = new_count

  res = []
  for n in count:
    if nums.count(n) > len(nums) // k:
      res.append(n)
  return res

print(majorityElement([3,2,3]))
print(majorityElement([1]))
print(majorityElement([1, 2]))
```

---

## ðŸ”¹ Classical Misraâ€“Gries Algorithm

### Steps:

1. Iterate through array:
   - If element is a tracked candidate â†’ increment its counter.
   - If not and fewer than `k-1` candidates â†’ add it.
   - Otherwise decrement all counters.
2. Verify candidates in a final pass.

### Complexity

- **Time Complexity**
  - One scan through array â†’ **O(n)**.
  - Final verification â†’ **O(nk) = O(n)**.
  - âœ… Overall: **O(n)**

- **Space Complexity**
  - Stores at most `k-1` counters â†’ **O(k)**

---

## ðŸ”¹ Comparison

| Aspect               | Hashmap Version                                    | Misraâ€“Gries                   |
| -------------------- | -------------------------------------------------- | ----------------------------- |
| **Time Complexity**  | O(n) (extra overhead from rebuilding dictionaries) | O(n) (more efficient updates) |
| **Space Complexity** | O(k)                                               | O(k)                          |
| **Practical Speed**  | Slightly slower (extra allocations)                | Faster, minimal overhead      |

---

## âœ… Conclusion

Both methods achieve the **same asymptotic complexity**:

- **O(n) time**
- **O(k) space**

```python
from collections import Counter

def misra_gries(nums):
  k = 3
  # Step 1: first pass - find candidates
  counters = {}

  for x in nums:
    if x in counters:
      counters[x] += 1
    elif len(counters) < k-1:
      counters[x] = 1
    else:
      # decrement all counters
      to_remove = []
      for key in counters:
        counters[key] -= 1
        if counters[key] == 0:
          to_remove.append(key)
      for key in to_remove:
        del counters[key]

  # Step 2: verify real counts
  # Reset counts for only the candidates
  real_counts = Counter()
  for x in nums:
    if x in counters:
      real_counts[x] += 1

  n = len(nums)
  result = [x for x in real_counts if real_counts[x] > n // k]
  return result

print(misra_gries([3,2,3]))
print(misra_gries([1]))
print(misra_gries([1, 2]))
```

However, **Misraâ€“Gries is more optimal in practice** because it avoids repeatedly creating new dictionaries and simply decrements counts in place.
