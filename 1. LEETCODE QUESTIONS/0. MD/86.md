# Intuition

The problem asks us to count the number of **hills** and **valleys** in an array.  
A **hill** is a point where the value is greater than its neighbors, and a **valley** is where it’s smaller than its neighbors.  
However, consecutive equal elements (like `[2, 2, 2]`) can make this tricky — they don’t change the hill/valley structure, so we need to handle them first.

---

# Approach

1. **Remove consecutive duplicates:**  
   Since equal consecutive numbers don’t affect the shape of the terrain (hill/valley), we first compress the array to only include changes in value.

   Example:  
   `[2, 2, 3, 4, 4, 1, 1, 2]` → `[2, 3, 4, 1, 2]`

2. **Check each middle element:**  
   After compression, loop through the array from index `1` to `len(compressed) - 2`.
   - If an element is **greater than both neighbors**, it’s a **hill**.
   - If it’s **smaller than both neighbors**, it’s a **valley**.

3. **Count hills and valleys:**  
   For each such element, increment the counter.

4. **Return the count** at the end.

---

# Complexity

- **Time complexity:** $$O(n)$$ — We traverse the list twice (once for compression, once for counting).
- **Space complexity:** $$O(n)$$ — For storing the compressed version of the input array.

---

# Code

```python3 []
class Solution:
    def countHillValley(self, nums: List[int]) -> int:
        compressed = [nums[0]]

        # Step 1: Remove consecutive duplicates
        for i in range(1, len(nums)):
            if nums[i] != nums[i-1]:
                compressed.append(nums[i])

        count = 0

        # Step 2: Count hills and valleys
        for i in range(1, len(compressed) - 1):
            if compressed[i-1] < compressed[i] > compressed[i+1]:
                count += 1
            elif compressed[i-1] > compressed[i] < compressed[i+1]:
                count += 1

        return count

```
