# Intuition

We need to return an array where each element is the **product of all other elements except itself**.  
A naive approach would multiply all elements for each position, but that would be $$O(n^2)$$.  
Instead, we can use **prefix and suffix products** to calculate this efficiently.

---

# Approach

1. Initialize an array `answer` of length `n` with zeros.
2. Compute **prefix products** (product of all elements to the left of current index):
   - Set `answer[0] = 1` since there are no elements to the left of the first element.
   - Iterate `i` from 1 to `n-1`, updating `answer[i] = answer[i-1] * nums[i-1]`.
3. Compute **suffix products** (product of all elements to the right of current index) on the fly:
   - Initialize `suffix = 1`.
   - Iterate `i` from `n-1` to 0:
     - Multiply `answer[i]` by `suffix` (which contains the product of elements to the right).
     - Update `suffix *= nums[i]` to include the current element for the next iteration.
4. Return the `answer` array.

This ensures that for each index, `answer[i]` contains the product of all elements except `nums[i]` **without using extra arrays**.

---

# Complexity

- **Time Complexity:** $$O(n)$$
  - One pass for prefix products and one pass for suffix products.

- **Space Complexity:** $$O(1)$$ (excluding the output array)
  - We only use a single variable `suffix`. The output array does not count as extra space.

---

# Code

```python3 []
class Solution:
    def productExceptSelf(self, nums: List[int]) -> List[int]:
        n = len(nums)
        answer = [0]*n
        answer[0] = 1
        suffix = 1

        # prefix products
        for i in range(1, n):
            answer[i] = answer[i-1] * nums[i-1]

        # multiply with suffix products
        for i in range(n-1, -1, -1):
            answer[i] *= suffix
            suffix *= nums[i]

        return answer

```
