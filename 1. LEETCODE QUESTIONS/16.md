# What the code is trying to do

```
def isValid(s: str) -> bool:
    mappedBrackets = {")": "(", "}": "{", "]": "["}
    stack = []

    for i in range(len(s)):
        c = s[i]
        if c not in mappedBrackets:
            stack.append(c)
        else:
            if not stack:
                return False
            topElement = stack.pop()
            if topElement != mappedBrackets.get(c):
                return False
    return not stack


print(isValid("()[]{}"))
print(isValid("([)]"))
print(isValid("(]"))
print(isValid("([])"))
```

We want to check if every opening bracket has a correctly-typed closing bracket in the correct order (properly nested). Example: `"([{}])"` is valid; `"(]"` is not.

Line-by-line

```
mappedBrackets = {")": "(", "}": "{", "]": "["}
```

- This is a dictionary that maps each closing bracket to the opening bracket it expects.
- Why closing → opening (and not opening → closing)?
  - Because when we read a closing bracket, we want to quickly know what opening bracket should be on top of the stack to match it.

```
stack = []
```

- We’ll use a list as a stack (LIFO: last in, first out).
- We push opening brackets as we see them.
  - When we see a closing bracket, we pop and check if it matches.

```
for i in range(len(s)):
    c = s[i]
```

- Iterate through the string by index and grab the current character `c`.
- (Python note: you could also write `for c in s:`, but your version is fine and explicit.)

```
if c not in mappedBrackets:
    stack.append(c)
```

- If `c` is not one of the closing brackets (`)`, `}`, `]`), then in this problem it must be an opening bracket (`(`, `{`, `[`).
- We push it onto the stack to be matched later.

```
else:
    if not stack:
        return False
```

- Now we’re in the case where c is a closing bracket.
- If the stack is empty, there’s no opening bracket available to match this closer → invalid immediately.

```
topElement = stack.pop()
```

- Pop the most recent opening bracket we saw.
- This is the only one that could legally match the current closing bracket (because of nesting rules).

```
if topElement != mappedBrackets.get(c):
    return False
```

- Look up what opening bracket is expected for this closer via the map.

For example, if c == ')', mappedBrackets[')'] is '('.

- Compare it against the popped opening bracket.
- If they differ, the types or nesting are wrong → invalid.
- `.get(c)` vs `[...]`: since you already know `c` is a key (we’re in the `else` branch), both are equivalent here. `.get` just avoids a `KeyError` in edge cases.

```
return not stack
```

- After processing the whole string:
  - If the stack is empty, every opening bracket found a proper closing partner → valid → True.
  - If anything is left on the stack, those openings were never closed → invalid → False.
- `not stack` is `True` when the list is empty in Python.

```
print(isValid("()[]{}"))
```

- Example call. This prints True because each pair is balanced and not nested incorrectly.

## Dry runs

`"()[]{}"`

1. `'('` → opening → push → stack: `['(']`
2. `')'` → closing → pop `(` → expected for `')'` is `'('` → match
3. `'['` → push → `['[']`
4. `']'` → pop `[` → expected `'['` → match
5. `'{'` → push → `['{']`
6. `'}'` → pop `{` → expected `'{'` → match
   End: stack empty → True.

## `"(]"`

1. `'('` → push → `['(']`
2. `']'` → closing → pop `'('` → expected for `']'` is `'['` → mismatch → `False`.

## `"]"` (starts with closing)

- `']'` is closing, stack is empty → immediate False.

## `""` (empty string)

- Loop doesn’t run; stack is empty → not stack is True → valid by convention.

## Why a stack?

Because of nesting. The most recent opening bracket must be the first one to close—exactly how a LIFO stack behaves. This lets us validate in one pass without backtracking.

## Complexity

- Time: `O(n)` — each character is pushed/popped at most once.
- Space: `O(n)` worst-case — all openings go onto the stack (e.g.,`"((((("`).

## Common pitfalls this code avoids

- Starting with a closing bracket (caught by `if not stack`).
- Mismatched types (caught by comparing `topElement` with the mapped expectation).
- Extra trailing openings (caught by `return not stack`).

## The intuition (step-by-step reasoning like in interviews)

1. Problem: I need to check brackets are valid.
2. First thought: Every opening must be closed → I need to store openings somewhere until I find their closing partners.
3. But closures must follow LIFO order → stack is natural.

4. Now: how do I know if the popped opening matches the current closing?

- I could write multiple ifs.
- But I want something scalable (imagine if there were 20 types of brackets).
- **HashMap** gives me instant lookup.

5. Together:

- Use stack to manage order.
- Use hashmap to manage matching types.

**That’s why this solution feels almost "obvious" once you break down the requirements.**
