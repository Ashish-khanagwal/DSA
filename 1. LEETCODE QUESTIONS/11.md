# Intuition

The input array nums is already sorted, but it can have both negative and positive numbers.

- Squaring negative numbers makes them positive, so the “sorted order” gets disturbed.
- The largest square will always come from either the leftmost (most negative) or the rightmost (most positive) number.

So, instead of squaring everything and sorting (which would cost extra time), we can use a two-pointer technique:

- Compare absolute values at both ends.
- Place the bigger square at the end of the result array.
- Move the corresponding pointer inward.

This way, we fill the result array from right to left.

# Approach

1. Initialize two pointers:
   - l = 0 (start of array)
   - r = n - 1 (end of array)
2. Create a result array res of length n.
3. Use pos = n - 1 to track where to insert the next largest square in res.
4. While l <= r:
   - Compare abs(nums[l]) and abs(nums[r]).
   - Square the larger one and put it at res[pos].
   - Move the corresponding pointer (l or r).
   - Decrement pos.
5. Return res.

# Complexity

- Time complexity: O(n)
  Every element is checked once.

- Space complexity: O(n)
  We use an extra result array of size n.

# Code

```python3 []
class Solution:
    def sortedSquares(self, nums: List[int]) -> List[int]:
        n = len(nums)
        l, r = 0, n - 1
        res = [0] * n
        pos = n - 1

        while l <= r:
            if abs(nums[l]) > abs(nums[r]):
                res[pos] = nums[l] * nums[l]
                l += 1
            else:
                res[pos] = nums[r] * nums[r]
                r -= 1
            pos -= 1
        return res
```
