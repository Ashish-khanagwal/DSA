# Intuition

We want to identify **stores with inventory imbalance**, where premium products
(highest price) are stocked in smaller quantities than budget products
(lowest price).

For each store, we need to:

- find the **most expensive** and **cheapest** products
- compare their **quantities**
- calculate how imbalanced the inventory is

Since these requirements depend on **per-store aggregates**, the solution must
compute store-level statistics before applying filters.

---

# Approach

1. **Compute price extremes per store**  
   Use a CTE to find the maximum and minimum product prices for each store.

2. **Join back to inventory**  
   Map the max and min prices back to their corresponding product names and
   quantities using conditional aggregation.

3. **Calculate imbalance ratio**  
   imbalance_ratio = cheapest_quantity / most_expensive_quantity

Round the value to 2 decimal places.

4. **Filter valid stores**

- Keep only stores with **at least 3 distinct products**
- Ensure the most expensive product has **lower stock** than the cheapest product

5. **Sort results**

- Descending by imbalance ratio
- Ascending by store name

---

# Complexity

- **Time Complexity:**  
  $$O(n)$$ — each inventory row is processed once during aggregation.

- **Space Complexity:**  
  $$O(s)$$ — where `s` is the number of stores (CTE output size).

---

# Code

```sql
WITH price_stats AS (
 SELECT
     store_id,
     MAX(price) AS max_price,
     MIN(price) AS min_price
 FROM inventory
 GROUP BY store_id
)

SELECT
 s.store_id,
 s.store_name,
 s.location,
 MAX(CASE WHEN i.price = ps.max_price THEN i.product_name END) AS most_exp_product,
 MAX(CASE WHEN i.price = ps.min_price THEN i.product_name END) AS cheapest_product,
 ROUND(
     MAX(CASE WHEN i.price = ps.min_price THEN i.quantity END) /
     MAX(CASE WHEN i.price = ps.max_price THEN i.quantity END),
     2
 ) AS imbalance_ratio
FROM stores s
JOIN price_stats ps
 ON s.store_id = ps.store_id
JOIN inventory i
 ON s.store_id = i.store_id
GROUP BY
 s.store_id,
 s.store_name,
 s.location,
 ps.max_price,
 ps.min_price
HAVING
 COUNT(DISTINCT i.product_name) >= 3
 AND
 MAX(CASE WHEN i.price = ps.max_price THEN i.quantity END) <
 MAX(CASE WHEN i.price = ps.min_price THEN i.quantity END)
ORDER BY
 imbalance_ratio DESC,
 s.store_name ASC;
```
