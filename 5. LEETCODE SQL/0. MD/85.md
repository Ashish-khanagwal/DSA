# üß† Intuition

The problem is about identifying **churn-risk customers** by analyzing how their subscription behavior has changed over time.  
A churn-risk customer shows **warning signs before cancelling**, such as downgrading their plan and generating significantly less revenue than they once did, while still being an active subscriber.

This means we must:

- Track the **latest subscription state** per user
- Analyze their **historical behavior** (downgrades and peak revenue)
- Measure how long they have been subscribed

Since we need both **row-level ordering** (latest event) and **user-level aggregation**, window functions combined with aggregation are the most natural solution.

---

# üß© Approach

1. **Rank subscription events per user**
   - Use `ROW_NUMBER()` partitioned by `user_id` and ordered by `event_date DESC`
   - This allows us to easily identify the **most recent event** for each user

2. **Aggregate per user**  
   From the ranked events, compute:
   - The **last event type**, **current plan**, and **current monthly amount**
   - The **maximum historical monthly amount**
   - The **number of downgrade events**
   - The **first** and **last** subscription dates

3. **Compute days as subscriber**
   - Use `DATEDIFF(last_event_date, first_event_date)`

4. **Apply churn-risk filters**
   - User is **currently active** (`last_event <> 'cancel'`)
   - At least **one downgrade** in history
   - Current revenue is **less than 50%** of historical maximum
   - Subscription duration is **at least 60 days**

5. **Sort the results**
   - By `days_as_subscriber` in descending order
   - Then by `user_id` in ascending order

---

# ‚è±Ô∏è Complexity

- **Time complexity:**  
  $$O(n \log n)$$
  - Window function ordering dominates due to sorting events per user

- **Space complexity:**  
  $$O(n)$$
  - Intermediate CTEs store ranked and aggregated user data

---

# Code

```mysql []
WITH ranked_events AS (
    SELECT
        user_id,
        event_date,
        event_type,
        plan_name,
        monthly_amount,
        ROW_NUMBER() OVER (
            PARTITION BY user_id
            ORDER BY event_date DESC
        ) AS rn
    FROM subscription_events
),
user_aggregates AS (
    SELECT
        user_id,

        MAX(CASE WHEN rn = 1 THEN event_type END) AS last_event,
        MAX(CASE WHEN rn = 1 THEN plan_name END) AS current_plan,
        MAX(CASE WHEN rn = 1 THEN monthly_amount END) AS current_monthly_amount,

        MAX(monthly_amount) AS max_historical_amount,
        SUM(CASE WHEN event_type = 'downgrade' THEN 1 ELSE 0 END) AS downgrade_count,
        MIN(event_date) AS first_event_date,
        MAX(event_date) AS last_event_date
    FROM ranked_events
    GROUP BY user_id
)
SELECT
    user_id,
    current_plan,
    current_monthly_amount,
    max_historical_amount,
    DATEDIFF(last_event_date, first_event_date) AS days_as_subscriber
FROM user_aggregates
WHERE last_event <> 'cancel'
  AND downgrade_count >= 1
  AND current_monthly_amount < 0.5 * max_historical_amount
  AND DATEDIFF(last_event_date, first_event_date) >= 60
ORDER BY
    days_as_subscriber DESC,
    user_id ASC;
```
