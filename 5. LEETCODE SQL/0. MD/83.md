# ðŸ§  Intuition

To identify **consistently improving employees**, we must focus on the **trend** of their most recent performance, not their entire history.

The key observations are:

- Only the **last 3 reviews** matter (by review date).
- Ratings must be **strictly increasing** across these 3 reviews.
- Simple aggregation (`GROUP BY`) is insufficient because **order matters**.
- We need to compare consecutive reviews and compute an **improvement score** based on the earliest and latest ratings in the last three reviews.

This naturally leads to a solution using **window functions**.

---

# ðŸ§© Approach

1. **Rank reviews per employee by date (descending)**
   - Use `ROW_NUMBER()` to identify the most recent reviews.
   - This allows us to isolate the **latest 3 reviews** per employee.

2. **Keep only the last three reviews**
   - Filter rows where `rn <= 3`.

3. **Compare ratings in chronological order**
   - Use `LAG()` to access previous ratings within the last three reviews.
   - This helps verify that ratings are **strictly increasing**.

4. **Validate improvement conditions**
   - Ensure exactly 3 reviews exist.
   - Ensure each rating is greater than the previous one.
   - Compute the **improvement score** as:
     ```
     max_rating âˆ’ min_rating
     ```

5. **Join with the employees table**
   - Retrieve employee names.
   - Order results by improvement score (descending), then name (ascending).

---

# â±ï¸ Complexity

- **Time complexity:**  
  $$O(n \log n)$$
  - Sorting reviews per employee for window functions dominates the cost.

- **Space complexity:**  
  $$O(n)$$
  - Intermediate CTEs store ranked and filtered review data.

---

# ðŸ’» Code

```mysql
WITH ranked_reviews AS (
    SELECT
        pr.employee_id,
        pr.review_date,
        pr.rating,
        ROW_NUMBER() OVER (
            PARTITION BY pr.employee_id
            ORDER BY pr.review_date DESC
        ) AS rn
    FROM performance_reviews pr
),
last_three AS (
    SELECT
        employee_id,
        review_date,
        rating,
        LAG(rating, 1) OVER (
            PARTITION BY employee_id
            ORDER BY review_date
        ) AS prev_rating,
        LAG(rating, 2) OVER (
            PARTITION BY employee_id
            ORDER BY review_date
        ) AS first_rating
    FROM ranked_reviews
    WHERE rn <= 3
),
qualified AS (
    SELECT
        employee_id,
        MAX(rating) - MIN(rating) AS improvement_score
    FROM last_three
    GROUP BY employee_id
    HAVING
        COUNT(*) = 3
        AND MIN(rating) < MAX(rating)
        AND MIN(
            CASE
                WHEN prev_rating IS NULL THEN 1
                WHEN rating > prev_rating THEN 1
                ELSE 0
            END
        ) = 1
)
SELECT
    e.employee_id,
    e.name,
    q.improvement_score
FROM qualified q
JOIN employees e
    ON e.employee_id = q.employee_id
ORDER BY
    q.improvement_score DESC,
    e.name ASC;
```
