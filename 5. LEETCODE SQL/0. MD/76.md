# Intuition

The goal is to analyze user activity data to identify **users who converted from a free trial to a paid subscription** and compute:

- the **average duration of free trial activities**
- the **average duration of paid activities**

At first glance, it may seem natural to use a **self-join**:

- one copy of the table for `free_trial` activities
- another copy for `paid` activities  
  and then ensure that the paid activity happens **after** the free trial.

---

# Approach

1. Use a **self-join** on the `UserActivity` table using `user_id` to connect free trial and paid activities for the same user.
2. Apply filters in the `WHERE` clause:
   - `f.activity_type = 'free_trial'`
   - `u.activity_type = 'paid'`
   - `u.activity_date > f.activity_date` to ensure correct order
3. Use conditional aggregation to compute:
   - average free trial duration
   - average paid duration
4. Group results by `user_id` and order them as required.

⚠️ **Important note:**  
This approach looks reasonable but is logically flawed because filtering rows in the `WHERE` clause happens **before aggregation**, which can remove rows needed to compute averages correctly. This is why such solutions often lead to incorrect or `NULL` results for one of the averages.

---

# Complexity

- **Time Complexity:**  
  $$O(n^2)$$ in the worst case due to the self-join on the same table.

- **Space Complexity:**  
  $$O(1)$$ extra space (excluding join processing by the database).

---

# Code

```sql
SELECT DISTINCT f.user_id,
    ROUND(
        SUM(CASE WHEN f.activity_type = 'free_trial' THEN f.activity_duration ELSE 0 END)
        / COUNT(CASE WHEN f.activity_type = 'free_trial' THEN 1 END),
    2) AS trial_avg_duration,
    ROUND(
        SUM(CASE WHEN u.activity_type = 'paid' THEN u.activity_duration ELSE 0 END)
        / COUNT(CASE WHEN u.activity_type = 'paid' THEN 1 END),
    2) AS paid_avg_duration
FROM UserActivity f
JOIN UserActivity u
    ON f.user_id = u.user_id
WHERE f.activity_type = 'free_trial'
  AND u.activity_type = 'paid'
  AND u.activity_date > f.activity_date
GROUP BY user_id
ORDER BY user_id;
```
