# Intuition

Each DNA sample needs to be analyzed for the presence of specific biological
patterns (motifs), such as start codons, stop codons, repeated sequences,
and consecutive nucleotides.

Instead of filtering rows, we compute **boolean indicators (0/1)** for each
pattern so that every sample can be evaluated independently.

---

# Approach

For each `dna_sequence`, we check:

1. **Start codon**
   - A valid start codon begins with `ATG`
   - Use `LIKE 'ATG%'`

2. **Stop codon**
   - A valid stop codon ends with `TAA`, `TAG`, or `TGA`
   - Use `REGEXP '(TAA|TAG|TGA)$'`

3. **ATAT motif**
   - Check if the sequence contains the repeated pattern `ATAT`
   - Use `REGEXP 'ATAT'`

4. **At least 3 consecutive G's**
   - Detect `GGG` or more
   - Use `REGEXP 'G{3,}'`

Each condition is expressed using a `CASE WHEN` statement that returns `1`
if the pattern exists, otherwise `0`.

---

# Complexity

- **Time Complexity:**  
  $$O(n \cdot m)$$  
  where `n` is the number of rows and `m` is the average DNA sequence length.

- **Space Complexity:**  
  $$O(1)$$  
  since only computed columns are added.

---

# Code

```sql
SELECT
    sample_id,
    dna_sequence,
    species,
    CASE
        WHEN dna_sequence LIKE 'ATG%' THEN 1
        ELSE 0
    END AS has_start,
    CASE
        WHEN dna_sequence REGEXP '(TAA|TAG|TGA)$' THEN 1
        ELSE 0
    END AS has_stop,
    CASE
        WHEN dna_sequence REGEXP 'ATAT' THEN 1
        ELSE 0
    END AS has_atat,
    CASE
        WHEN dna_sequence REGEXP 'G{3,}' THEN 1
        ELSE 0
    END AS has_ggg
FROM Samples
ORDER BY sample_id;
```
